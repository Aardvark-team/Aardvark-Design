# NeXT/GL
NeXTGL (NEwly-eXtensible Two-Generation Language) is a modern, high-level programming language.
### Hello World
```rust
// std/os makes up the stdlib
let std: module = @import("std")
// type inference is allowed
let os = @import("os")

// stack is not implicit
var stack: [4096]u8 = undefined

// there is no main function
pub fn _start() void {
	// register access is direct
	@mov(esp, stack)

	// namespacing uses ::
	let stdout = os::IOStream::new("/dev/stdout")

	// methods use .
	stdout.write("Hello World!")

	return void{}
}
```
### Primitives
The primitives types are `int`, `uint`, `float`, & `fixed`. They are all implicitly word-sized, and `fixed` places the point in the center. To specify bitwidths use `iBB`, `uBB`, `fBB`, & `xBB_BB` (the former is the integer-part, the latter is the fractional part).

The compile-time only types are `module`, `string`, & `number`.

Numeric types are coerced from `number`, which is written `123.456`. They can be postfixed with `i u f x` for the four word-sized types, or with their bitwidth-specified type. Modules are produced with built-in functions. Strings are written with `"..."`. Coercing from `number` may fail, raising a compile-time error (e.g. `3.141592i` or `512u8`).

Values of type `float` or `fBB` can be coerced from `NaN`.

The type `void` has one value, `void{}`, which is generated by `break`, `continue`, `while`,  & `return`. The `for` and `if` statements can be used as expressions, so they do not have type `void`.
### Modifiers
The modifier types are `[]T`, `[n]T`, `[*]T`, `[*:S]T`,, `T throw F`, `(F)T`, `?*T`, `*T`, `?*var T`, `*var T`, `?*const T`, `*const T`, `const` & `[T;n]` for slices, arrays, views, sentinel-terminated arrays, fallibles, procedures, options, pointers, optional pointers to mutable values, pointers to mutable values, optional pointers to immutable values, pointers to immutable values, compile-time known values, and vectors. Note that `n` is of type `number` and `S` is of type `const T`.

The types `[]`, `[*]`, `[*:S]`, `throw`, & functions must be referenced with indirection, since their time is runtime-known (e.g. `*var []u8`).

The list-like types `[]`, `[n]`, `[*]`, `[*:S]`, and `[T;n]` are indexed with `arr[val]` (with `val: uint`).  They are written `[1, 2, 3]`, `{1, 2, 3}`, and (for vectors) `@vec(1, 2, 3)`.  All of them except views implement generators, and vector/array generators can be inlined.

The sum-types `T throws F` and `?*T` can be pattern matched. `throws` is pattern matched with `try val catch(F err) { ... }`, and `?*` is pattern matched with `try val else { val }`. Both can be pattern matched with `if let id = val { ... }` and optional `else let id = err { ... }`/`else { ... }` respectively. The `else`-`let` can be ommitted.

Pointers to mutable values can be assigned to either with `:=` or with compound-assignment (e.g. `>>=`). Generic pointers can be coerced from either mutable or immutable pointers, but `*const` is used for optimization. Identifiers declared with `let` are `*const` and identifiers declared with `var` are `*var`. There is no distinction between lvalues and pointers to rvalues.

The type `fn` can be used directly at compile-time, but requires indirection at runtime. It can be used in function-call expressions.

Comparison between pointers usually compares the pointed-to values, so the `is` operator is provided for pointer comparison.

Strings can coerce to pointers (immutable or mutable) to slices, arrays, zero-terminated arrays, vectors, or views of integers. This can be written into the literal with `"..."modT` (e.g. `"hi"[]u8`). The character-encoding used is implementation-defined.
### Variables
Declare variables with `var` or `let` (for mutable or immutable cells respectively). They can be stack-allocated or emulated with registers. Type annotations are optional.
```rust
let w: u8 = 0u8
let x = 0u8
var y: u8 = 0u8
var z = 0u8
```
### Procedures
Declare a procedure with `fn`. Return a value with `return`.
```rust
fn square(x u8) u8 {
	return x * X
}
```
Procedures can be introduced inline, but cannot create a lexical closure.
```rust
fn square(x u8) u8 {
	let z = 0

	fn mul(x u8, y u8) u8 {
		// ERROR: z is not defined
		let cpy = z

		// This is OK
		return x * y
	}

	return mul(x, x)
}
```
### Anonymous Functions
Functions can be declared anonymously with `=>` or `fn`.
```rust
let square: (u8)u8 = fn(x u8) u8 {
	return x * x
}

let square = x => x * x
```
### Product Types
Declare a set of grouped variables with `struct`. Properties are aligned to word-size unless the `packed` keyword is used.
```rust
let Point = struct {
	x: u8,
	y: u8,
}
```
Write literals with the same syntax.
```rust
let origin = Point {
	x: 0,
	y: 0,
}
```
When the type is known, `.` can be used.
```rust
let origin: Point = .{
	x: 0,
	y: 0,
}
```
Access fields with `.`.
```rust
let zero = origin.x
```
### Sum Types
Declare a sum type with `union`.
```rust
let Pet = union {
	cat: Cat,
	dog: Dog,
}
```
Pattern match over it with `if`-`let`, `else`-`if`-`let`, and `else`.
```rust
let pet: Pet = .{ cat: Cat::new() }

if let cat = pet.cat {
	// ...
} 
// The match must be exhaustive for "else"
else let dog = pet.dog {
	// ...
}
```
You can also do member-access returning an optional.
```rust
let dog =
	try pet.dog
	else { undefined }
```
You can remove the tag, allowing direct-member access, with `packed union`.
### Enumerations
Use `enum` to declare an enumeration. Add a `(...)` clause for an underlying integer type (`uint` by default).
```rust
let MyBool = enum {
	true,
	false,
}

let MyBetterBool = enum(u1) {
	true,
	false,
}
```
### While
Use the `while` keyword to create a while loop.
```rust
var count = 0
while(count < 100) {
	count += 1
	do_a_thing(count)
}

var next = 0
while(next < 100) : (next += 1) {
	do_a_thing(next)
}
```
You can inline a while loop with `const` and use a `const` variable immediately before it.
```rust
const count = 0
const while(count < 100) : (count += 1) {
	do_a_thing(count)
}

let cpy = count // ERROR
```
This will allow `count` to be compile-time known, and will simply generate (in this case) 100 copies of the loop.

The `break` keyword ends while iteration, and `continue` ends the current iteration.
### For
Use `for val in list { ... }` for loops. Use `const for` for compile-time for loops, which is allowed only when `list` is compile-time known.
```rust
const for let count: number in 1..100 {
	// count: number
	do_a_thing(count)
}

for let count: u8 in 1..100 {
	do_a_thing(count)
}
```
Implement generators with a `for` method and the `yield` keyword. The `break` keyword ends a generator, and the `continue` keyword returns control flow to the generator without finishing the current iteration.
### Low-Level Instructions
Operation codes from the underlying 1GL implemented by hardware can be accessed with `@op(opcode, args)`. For example, `@op(lgdt, some_value)` on an x64 CPU will set the global descriptor table pointer to `some_value`.

To read from a register use `@mov(reg)`, and to write to it use `@mov(reg, val)`. This will prevent said register from being used to emulate variables in the current procedure, but not necessarily called procedures.

To make an interrupt, use `@int(num, vals)`. To make a system call, use `@sys(num, vals)`. To write to a serial port use `@out(port, value)`.

To bitwise-cast size-compatible types use `@bit_cast(target, val)`.
### Undefined
The value `null` coerces to a `?*` of a given type that points to no value. The value `undefined` coerces to any type and allows an unspecified value to be placed into a variable or register.
### Undefined Behaviour
The language has no UB by default. However, to enable greater optimizations, use `@optimize(...)` to pass in a set of `string` values, which represent optimization flags (e.g. `"no-divide-by-zero"`). These apply to the current scope and all subscopes, and are overridable.
### Methods
Use `impl type` to implement a type. This allows you to provide methods and static functions, called with `.` and `::` respectively.
```rust
impl Point {
	// Method
	fn len(self: Point) {
		return std::sqrt(self.x * self.x + self.y * self.y)
	}

	// Static
	fn new(x u8, y u8) Point {
		return .{ x: x, y: y, }
	}
}
```
### Memory
The procedures `@memcmp` & `@memcpy` can be implemented with the following signatures.
```
fn @memcmp(*[*]u8, *[*]u8, u8) u1

fn @memcpy(*var [*]u8, *[*]u8, u8) void
```
The compiler may insert calls to these procedures anywhere it sees fit, so they are expected to have no side effects aside from the mutable parameter to `@memcpy`.